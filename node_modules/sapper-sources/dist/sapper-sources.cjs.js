'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

function _interopNamespace(e) {
  if (e && e.__esModule) { return e; } else {
    var n = {};
    if (e) {
      Object.keys(e).forEach(function (k) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      });
    }
    n['default'] = e;
    return n;
  }
}

var fs = _interopDefault(require('fs'));
var path = _interopDefault(require('path'));
var uuidv5 = _interopDefault(require('uuidv5'));
var marked = _interopDefault(require('marked'));
var fm = _interopDefault(require('front-matter'));

const CWD = process.cwd();
const seedConstant = 'sapper-sources';

const createNodeId = id => {
  if (typeof id === `number`) {
    id = id.toString();
  } else if (typeof id !== `string`) {
    console.warn(
      `Parameter passed to createNodeId must be a String or Number (got ${typeof id})`,
    );
  }

  return uuidv5(uuidv5('URL', seedConstant), id);
};

const getFilesOfType = (dir, filelist, fileExtension = '') => {
  const POSTS_DIR = path.join(CWD, dir);
  const files = fs.readdirSync(POSTS_DIR);
  filelist = filelist || [];
  files
    .filter(file =>
      fileExtension ? path.extname(file) === fileExtension : true,
    )
    .forEach(function(file) {
      if (fs.statSync(POSTS_DIR + file).isDirectory()) {
        filelist = getFilesOfType(dir + file + '/', filelist, fileExtension);
      } else {
        filelist.push(dir + file);
      }
    });
  return filelist
    .map(path => {
      try {
        const content = fs.readFileSync(CWD + path, 'utf8');
        return { path, content };
      } catch (err) {
        console.warn(err);
        return null;
      }
    })
    .filter(fileContent => !!fileContent);
};

async function gatsbyPluginHelper(plugin, options) {
  const pluginPath = require.resolve(plugin);
  const controller = await new Promise(function (resolve) { resolve(_interopNamespace(require(pluginPath))); });

  const contents = [];
  const createNode = data => contents.push(data);

  await controller.sourceNodes(
    {
      actions: { createNode },
      createNodeId,
    },
    options,
  );

  return contents;
}

function gatsbyPlugin(plugin) {
  if (!plugin) {
    return null;
  }

  return async options => {
    return await gatsbyPluginHelper(plugin, options);
  };
}

const DEFAULT_DIR = '/content/';

const transformSlug = text =>
  text
    .replace(/[^0-9A-z ]/gi, '')
    .replace(' ', '-')
    .toLowerCase();

const processFile = ({ path, content }) => {
  const ParsedMarkdown = fm(content);
  const frontmatter = ParsedMarkdown.attributes;
  const contentHtml = marked(ParsedMarkdown.body);

  return {
    path,
    frontmatter,
    contentHtml,
    slug: transformSlug(frontmatter.title),
  };
};

const getFileContent = (contentPath = DEFAULT_DIR) => {
  const files = getFilesOfType(contentPath);

  return files.map(processFile);
};

const markdownSource = options => {
  const { contentPath } = options;
  let contents = getFileContent(contentPath);

  return contents;
};

function main(config) {
  if (!config.plugin) {
    console.error('Plugin not defined');
    return;
  }
  const response = config.plugin(config.options);

  return Promise.resolve(response).then(contents => ({
    contents,
    ...config.options,
  }));
}

exports.default = main;
exports.gatsbyPlugin = gatsbyPlugin;
exports.markdownSource = markdownSource;
